
CREATE KEYSPACE ks_customer WITH REPLICATION {'class':'SimpleStrategy','replication_factor':1};

/* We also should consider possiblity of keys that are composite for entitlement. For example, tomorrow what if we have 
   composite keys */

CREATE TABLE customer_entity 
(lei text, 
 entity text, 
 entityOwner text, 
 entityContactDetails map<text, text>,
 PRIMARY KEY (lei)
 )

INSERT INTO customer_entity (lei,entity, entityOwner, entityContactDetails ) VALUES ('G20820052','AHHoldings International', 'Andrew Hobson', {'phone':'+61666666666','email':'andrew.h@gcc.com'});

INSERT INTO customer_entity (lei, entity, entityOwner, entityContactDetails ) VALUES ('G24707916','SAN Holdings International', 'Sanjeev Kumar', {'phone':'+617777777','email':'sanjeev.k@ecm.com'});

INSERT INTO customer_entity (lei, entity, entityOwner, entityContactDetails ) VALUES ('G55403998','BATA Groups Public Limited', 'Khanna Anand', {'phone':'+9198765211','email':'anand.kh@bata.com'});

INSERT INTO customer_entity (lei, entity, entityOwner, entityContactDetails ) VALUES ('G43103653','Federer Sports Private Limited', 'Roger Federer', {'phone':'+4487621212','email':'federer.r@fed.com'});

INSERT INTO customer_entity (lei, entity, entityOwner, entityContactDetails ) VALUES ('G43103653','Bulls and Finance Corporation', 'John Pope', {'phone':'+132322134','email':'john.pope@bull.com'});

/* extend this table to further  add the cell level security label. 
   Currently only the row level security would be enabled
PoC only will be based on schema and rls. CLS will be looked into later
Label checking will be at schemaDetails.cellLabel -> lei.cellLabel
*/


CREATE TABLE customer_entity_entitlement
	(
	 schemaName <text>,
	 lei <text>,
	 /* should contain additional security label at schema level 
	  { schemaColumnList map<text,text>,
		schemaKeyColumnList set<text>
	  }
	 */
	 -- Contains the key for which all the labels will be attached as value. We need to figure what about the composite key values
	 -- In case of composite key value it will be a different approach where key will have to be generate and stored alongside the 
	 -- schemaDetails map<text text>,
	 --EntitiledKeyValue map<text,text>
	 
	 -- just store the label in this column that will correspond to the lei. This will be used for access control at row level
	 -- this gives flexiblity to generate labels and add later on the fly. For example, country 'IND' as label.
	 rlsLabel set<text>, 
	 clsLabel map<text, text>
	 PRIMARY KEY (schemaName,lei)
	);


/*
Design Notes
===============

 The framework will work upon the general API syntax of CQL. There will be requests processed by "data enforcement monitor" while the micro service submits this  to central processing framework. 

Restful APi with parameters like 

PATH = service URI location/ instance / user token ....
select?= "SELECT * FROM customer_entity"
	
We will have to build a tanslator that will read roles, labels and regenerate the SQL based on the entitlements. For example,
SELECT lei, mask(name, prefix_4) as name, contact_details FROM customer_entity WHERE lei IN ([23432434],[3423423423],[234234234234]). 

Internally call the RestFUL API with the translated view of the data and pass back the result.

Currently only simple usecase to be considered that doesnt require complex integration of data. In case there is a requirement of complex integration or aggregated data requirements, we will have to build a ETL pipeline that will process in memory the request keeping the data enforcement engine as a layer in the middle. This again will depend on the features available in Hazelcast.

*/

/*
Table : entitlement_schema_policy
Description : All tables will be secured using data at schema level. We follow generally least access principle. Therefore any new table added will not be accesible until it is added to 'entitlement_schema_policy'.

entitledPolicyID (generated): A general integer identifier as a sequence number for the row. 
entitledPolicyDesc (optional): storing the purpose of this description. 
keyspace (mandatory): this is specific to the cassandra. It will be which keyspace we like to give access.

*/


CREATE TABLE entitlement_schema_policy
	(
	 entitledSchemaPolicyID int,
	 entitledPolicyDesc text,
	 keyspace text,
	 tableColumnName map<text,text>,
	 PRIMARY KEY (entitledSchemaPolicyID)
	);

/* 
rule condition only supports expression '=', '<=', '>=', '' and contains only columns from the specific table alone
*/
CREATE TABLE entitlement_rls_policy
	(
	 entitledRLSPolicyID int,
	 entitledPolicyDesc text,
	 keyspace text,
	 tableName set<text>,
	 ruleCondition <text>
	 PRIMARY KEY (entitledRLSPolicyID)
	);


CREATE TABLE user_entitle_by_schema_policy
	(
	 UserID text, 
	 entitledPolicyID int,
	 entitledPolicyDesc text,
	 keyspace text,
	 tableColumnName map<text,text>,
	 PRIMARY KEY ( UserID text, entitledPolicyID )	
	);


CREATE TABLE user_entitle_by_rls_policy
	(
	 UserID text,
	 entitledPolicyID int,
	 entitledPolicyDesc text,
	 tableName set<text>,
	 ruleCondition <text>
	 PRIMARY KEY (entitledPolicyLabel, entitledPolicyID)
	);


